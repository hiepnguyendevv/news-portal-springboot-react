// File: news-services/src/main/java/com/news/news_services/entity/RefreshToken.java
package com.news.news_services.entity;

import jakarta.persistence.*;

import java.time.Instant;

@Entity
@Table(name = "refresh_tokens")
public class RefreshToken {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @Column(name = "token_hash",nullable = false,unique = true)
    private String tokenHash;

    @Column(name = "expiresAt",nullable = false)
    private Instant expiresAt;

    @Column(name = "revoked",nullable = false)
    private boolean revoked = false;

    @Column(nullable = false)
    private String tokenFamily;

    @Column(name = "created_at")
    private Instant createdAt;

    public String getTokenFamily() {
        return tokenFamily;
    }

    public void setTokenFamily(String tokenFamily) {
        this.tokenFamily = tokenFamily;
    }

    public boolean isRevoked() {
        return revoked;
    }

    public void setRevoked(boolean revoked) {
        this.revoked = revoked;
    }

    public Instant getExpiresAt() {
        return expiresAt;
    }

    public void setExpiresAt(Instant expiresAt) {
        this.expiresAt = expiresAt;
    }

    public Instant getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(Instant createdAt) {
        this.createdAt = createdAt;
    }

    public String getTokenHash() {
        return tokenHash;
    }

    public void setTokenHash(String tokenHash) {
        this.tokenHash = tokenHash;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }
}

// File: news-services/src/main/java/com/news/news_services/repository/RefreshTokenRepository.java
package com.news.news_services.repository;

import com.news.news_services.entity.RefreshToken;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;

import java.util.List;
import java.util.Optional;

public interface RefreshTokenRepository extends JpaRepository<RefreshToken,Long> {
    Optional<RefreshToken> findByTokenHashAndRevokedFalse(String tokenHash);
    List<RefreshToken> findAllByUserId(Long userId);
    Optional<RefreshToken> findByTokenHash(String tokenHash);
    @Modifying
    @Query("UPDATE RefreshToken rt SET rt.revoked = true WHERE rt.tokenFamily = ?1")
    void revokeTokenFamily(String tokenFamily);
}

// File: news-services/src/main/java/com/news/news_services/security/CookieUtil.java
package com.news.news_services.security;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseCookie;
import org.springframework.stereotype.Component;

@Component
public class CookieUtil {
    @Value("${app.refreshCookieName}")
    private String refreshCookieName;

    @Value("${app.refreshCookiePath}")
    private String refreshCookiePath;

    @Value("${app.refreshCookieSecure}")
    private boolean refreshCookieSecure;

    @Value("${app.refreshExpirationMs}")
    private Long refreshExpirationMs;

    public ResponseCookie createRefreshCookie(String token){
        ResponseCookie cookie = ResponseCookie.from(refreshCookieName,token)
                .httpOnly(true)
                .secure(refreshCookieSecure)
                .maxAge(refreshExpirationMs/1000)
                .path(refreshCookiePath)
                .sameSite("Lax")
                .build();
        System.out.println("Cookie được tạo: " + cookie.toString());
        return cookie;
    }

    public ResponseCookie clearRefreshCookie(){
        return ResponseCookie.from(refreshCookieName)
                .httpOnly(true)
                .secure(refreshCookieSecure)
                .maxAge(0)
                .path(refreshCookiePath)
                .sameSite("Lax")
                .build();
    }
}

// File: news-services/src/main/java/com/news/news_services/security/JwtUtil.java
package com.news.news_services.security;

import io.jsonwebtoken.*;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;

import java.security.Key;
import java.util.Date;

@Component
public class JwtUtil {
    @Value("${app.jwtSecret}")
    private String jwtSecret;

    @Value("${app.jwtExpirationMs}")
    private int jwtExpirationMs;

    public String generateJwtToken(Authentication authentication) {
        String username =  authentication.getName();

        return Jwts.builder()
                .setSubject(username)
                .setIssuedAt(new Date())
                .setExpiration(new Date((new Date()).getTime() + jwtExpirationMs))
                .signWith(key(), SignatureAlgorithm.HS256)
                .compact();
    }

    public String generateTokenFromUsername(String username) {
        return Jwts.builder()
                .setSubject(username)
                .setIssuedAt(new Date())
                .setExpiration(new Date((new Date()).getTime() + jwtExpirationMs))
                .signWith(key(),SignatureAlgorithm.HS256)
                .compact();
    }

    private Key key() {
        return Keys.hmacShaKeyFor(Decoders.BASE64.decode(jwtSecret));
    }

    public String getUserNameFromToken(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(key())
                .build()
                .parseClaimsJws(token)
                .getBody()
                .getSubject();
    }

    public boolean validationJwtToken(String token) {
        try {
            Jwts.parserBuilder().setSigningKey(key()).build().parse(token);
            return true;
        } catch (MalformedJwtException e) {
            System.err.println("Invalid JWT token: " + e.getMessage());
        } catch (ExpiredJwtException e) {
            System.err.println("JWT token is expired: " + e.getMessage());
        } catch (UnsupportedJwtException e) {
            System.err.println("JWT token is unsupported: " + e.getMessage());
        } catch (IllegalArgumentException e) {
            System.err.println("JWT claims string is empty: " + e.getMessage());
        }
        return false;
    }
}

// File: news-services/src/main/java/com/news/news_services/service/RefreshTokenService.java
package com.news.news_services.service;

import com.news.news_services.dto.ExchangeTokenResponse;
import com.news.news_services.entity.RefreshToken;
import com.news.news_services.entity.User;
import com.news.news_services.repository.RefreshTokenRepository;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.time.Instant;
import java.util.Base64;
import java.util.Optional;
import java.util.UUID;

@Service
public class RefreshTokenService {
    @Autowired
    private RefreshTokenRepository refreshTokenRepository;

    @Value("${app.refreshExpirationMs}")
    private Long refreshExpirationMs;

    private String hashToken(String token){
        try{
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hash = digest.digest(token.getBytes(StandardCharsets.UTF_8));
            return Base64.getEncoder().encodeToString(hash);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private String generateNewToken(User user, String tokenFamily){
        String rawToken = UUID.randomUUID().toString();
        String tokenHash = hashToken(rawToken);

        RefreshToken newToken = new RefreshToken();
        newToken.setUser(user);
        newToken.setTokenHash(tokenHash);
        newToken.setTokenFamily(tokenFamily);
        newToken.setExpiresAt(Instant.now().plusSeconds(refreshExpirationMs/1000));
        newToken.setRevoked(false);
        newToken.setCreatedAt(Instant.now());

        refreshTokenRepository.save(newToken);
        return rawToken;
    }

    @Transactional
    public void revokedRefreshToken(String rawToken){
        if(rawToken == null){
            return;
        }
        String tokenHash = hashToken(rawToken);
        refreshTokenRepository.findByTokenHashAndRevokedFalse(tokenHash)
                .ifPresent(
                        token ->{
                            token.setRevoked(true);
                            refreshTokenRepository.save(token);
                        }
                );
    }

    @Transactional(noRollbackFor = SecurityException.class)
    public ExchangeTokenResponse exchangRefreshToken(String oldRawToken){
        String oldHashToken = hashToken(oldRawToken);

        Optional<RefreshToken> rf = refreshTokenRepository.findByTokenHashAndRevokedFalse(oldHashToken);
        if(rf.isEmpty()){
            Optional<RefreshToken> revokedToken = refreshTokenRepository.findByTokenHash(oldHashToken);
            if(revokedToken.isPresent() && revokedToken.get().isRevoked()){
                System.out.println("Phát hiện tái sử dùng refresh token");
                refreshTokenRepository.revokeTokenFamily(revokedToken.get().getTokenFamily());
                System.out.println("Xóa family liên quan: "+ revokedToken.get().getTokenFamily());


                throw new SecurityException("Phát hiện tái sử dụng Refresh Token!");
            }
            System.out.println("Token không hợp lệ");
            throw new SecurityException("Refresh Token không hợp lệ!");

        }
        RefreshToken oldToken = rf.get();

        if(oldToken.getExpiresAt().isBefore(Instant.now())){
            oldToken.setRevoked(true);
            refreshTokenRepository.save(oldToken);
            throw new SecurityException("Refresh Token đã hết hạn!");
        }

        oldToken.setRevoked(true);
        refreshTokenRepository.save(oldToken);

        User user = oldToken.getUser();

        String newRawToken = generateNewToken(oldToken.getUser(), oldToken.getTokenFamily());

        return new ExchangeTokenResponse(newRawToken,user);

    }

    public String createRefreshToken(User user){
        String tokenFamily = "family-" + UUID.randomUUID().toString();
        return generateNewToken(user,tokenFamily);
    }
}

// File: news-services/src/main/java/com/news/news_services/controller/AuthController.java
package com.news.news_services.controller;

import com.news.news_services.dto.ExchangeTokenResponse;
import com.news.news_services.dto.JwtResponse;
import com.news.news_services.dto.LoginRequest;
import com.news.news_services.dto.SignupRequest;
import com.news.news_services.entity.User;
import com.news.news_services.repository.UserRepository;
import com.news.news_services.security.CookieUtil;
import com.news.news_services.security.JwtUtil;
import com.news.news_services.security.UserPrincipal;
import com.news.news_services.service.RefreshTokenService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.ResponseCookie;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/auth")
public class  AuthController {

    @Autowired
    private AuthenticationManager authenticationManager;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Autowired
    private JwtUtil jwtUtil;

    @Autowired
    private RefreshTokenService refreshTokenService;

    @Autowired
    private CookieUtil cookieUtil;

    @PostMapping("/signin")
    public ResponseEntity<?> authenticateUser(@Valid @RequestBody LoginRequest loginRequest) {
        try{
            Authentication authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(
                            loginRequest.getUsername(),
                            loginRequest.getPassword()
                    )
            );

            SecurityContextHolder.getContext().setAuthentication(authentication);


            UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
            User user = userRepository.findById(userPrincipal.getId())
                    .orElseThrow(() -> new RuntimeException("User not found"));

            String jwt = jwtUtil.generateJwtToken(authentication);
            String rawRefreshToken = refreshTokenService.createRefreshToken(user);
            System.out.println("Token khi login: "+ rawRefreshToken);


            ResponseCookie refreshCookie = cookieUtil.createRefreshCookie(rawRefreshToken);


            return ResponseEntity.ok()
                    .header(HttpHeaders.SET_COOKIE, refreshCookie.toString())
            .body(JwtResponse.build(jwt,user));

        } catch (Exception e) {
            Map<String, String> error = new HashMap<>();
            error.put("error", "Đăng nhập thất bại: ");
            return ResponseEntity.badRequest().body(error);
        }

    }

    @PostMapping("/refresh")
    public ResponseEntity<?> refreshToken(@CookieValue(name = "${app.refreshCookieName}") String oldRawToken){
        try{
            ExchangeTokenResponse response = refreshTokenService.exchangRefreshToken(oldRawToken);
            String newRawRefreshToken = response.getNewRawRefreshToken();

            User user = response.getUser();

            System.out.println("Token sau khi refresh: "+ newRawRefreshToken);
            String newAccessToken = jwtUtil.generateTokenFromUsername(user.getUsername());
            
            // Set authentication vào SecurityContext sau khi refresh token
            // Để WebSocket và các request khác có thể sử dụng
            UserPrincipal userPrincipal = UserPrincipal.create(user);
            UsernamePasswordAuthenticationToken authentication =
                    new UsernamePasswordAuthenticationToken(userPrincipal, null, userPrincipal.getAuthorities());
            SecurityContextHolder.getContext().setAuthentication(authentication);
            
            ResponseCookie newRefreshCookie = cookieUtil.createRefreshCookie(newRawRefreshToken);
            return ResponseEntity.ok()
                    .header(HttpHeaders.SET_COOKIE, newRefreshCookie.toString())
                    .body(Map.of("accessToken", newAccessToken)); // Chỉ trả về AT mới

        }catch (Exception e){
            System.out.println("=== LỖI KHI REFRESH TOKEN ===");
            System.out.println("Lỗi: " + e.getMessage());
            e.printStackTrace();
            ResponseCookie clearCookie = cookieUtil.clearRefreshCookie();
            return ResponseEntity.status(401)
                    .header(HttpHeaders.SET_COOKIE, clearCookie.toString())
                    .body(Map.of("error", "Refresh Token không hợp lệ: " + e.getMessage()));
        }
    }

    @PostMapping("/signup")
    public ResponseEntity<?> registerUser(@Valid @RequestBody SignupRequest signupRequest) {
        try{
            if(userRepository.existsByUsername(signupRequest.getUsername())){
                Map<String, String> error = new HashMap<>();
                error.put("error", "Username đã được sử dụng!");
                return ResponseEntity.badRequest().body(error);
            }

            if(userRepository.existsByEmail(signupRequest.getEmail())){
                Map<String, String> error = new HashMap<>();
                error.put("error", "email đã được sử dụng!");
                return ResponseEntity.badRequest().body(error);
            }

            User user = new User();
            user.setUsername(signupRequest.getUsername());
            user.setEmail(signupRequest.getEmail());
            user.setPassword(passwordEncoder.encode(signupRequest.getPassword()));
            user.setFullName(signupRequest.getFullName());
            user.setPhone(signupRequest.getPhone());
            user.setRole(User.UserRole.USER);
            user.setStatus(User.UserStatus.ACTIVE);
            user.setEmailVerified(true);

            User savedUser = userRepository.save(user);

            Map<String, Object> response = new HashMap<>();
            response.put("message", "Đăng ký thành công!");
            response.put("user", Map.of(
                    "id", savedUser.getId(),
                    "username", savedUser.getUsername(),
                    "email", savedUser.getEmail(),
                    "fullName", savedUser.getFullName(),
                    "role", savedUser.getRole().name()
            ));
            return ResponseEntity.ok(response);
        }catch(Exception e){
            Map<String, String> error = new HashMap<>();
            error.put("error", "Đăng ký thất bại: " + e.getMessage());
            return ResponseEntity.badRequest().body(error);
        }
    }



    @GetMapping("/me")
    public ResponseEntity<?> getCurrentUser() {
        try {
            Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
            UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();

            User user = userRepository.findById(userPrincipal.getId())
                    .orElseThrow(() -> new RuntimeException("User not found"));

            Map<String, Object> response = new HashMap<>();
            response.put("id", user.getId());
            response.put("username", user.getUsername());
            response.put("email", user.getEmail());
            response.put("fullName", user.getFullName());
            response.put("role", user.getRole().name());
            response.put("status", user.getStatus().name());
            response.put("avatarUrl",user.getAvatarUrl());

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            Map<String, String> error = new HashMap<>();
            error.put("error", "Không thể lấy thông tin user: " + e.getMessage());
            return ResponseEntity.badRequest().body(error);
        }
    }



    @PutMapping("/me")
    public ResponseEntity<?> updateCurrentUser(@RequestBody Map<String, Object> updateData) {
        try {
            Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
            UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();

            User user = userRepository.findById(userPrincipal.getId())
                    .orElseThrow(() -> new RuntimeException("User not found"));

            if (updateData.containsKey("email")) {
                String newEmail = (String) updateData.get("email");
                if (newEmail != null && !newEmail.equals(user.getEmail()) && userRepository.existsByEmail(newEmail)) {
                    return ResponseEntity.badRequest().body(Map.of("error", "Email đã tồn tại"));
                }
                user.setEmail(newEmail);
            }

            //update full name
            if (updateData.containsKey("fullName")) {
                user.setFullName((String) updateData.get("fullName"));
            }

            //update phone
            if (updateData.containsKey("phone")) {
                user.setPhone((String) updateData.get("phone"));
            }

            if (updateData.containsKey("avatarUrl")) {
                user.setAvatarUrl((String) updateData.get("avatarUrl"));
            }

            if (updateData.containsKey("password")) {
                String password = (String) updateData.get("password");
                if (password != null && !password.isEmpty()) {
                    user.setPassword(passwordEncoder.encode(password));
                }
            }

            User saved = userRepository.save(user);

            Map<String, Object> response = new HashMap<>();
            response.put("id", saved.getId());
            response.put("username", saved.getUsername());
            response.put("email", saved.getEmail());
            response.put("fullName", saved.getFullName());
            response.put("role", saved.getRole().name());
            response.put("status", saved.getStatus().name());
            response.put("phone", saved.getPhone());
            response.put("avatarUrl", saved.getAvatarUrl());

            return ResponseEntity.ok(response);
        } catch (Exception e) {
            Map<String, String> error = new HashMap<>();
            error.put("error", "Không thể cập nhật hồ sơ: " + e.getMessage());
            return ResponseEntity.badRequest().body(error);
        }
    }

    @PostMapping("/logout")
    public ResponseEntity<?> logoutUser(@CookieValue(name = "${app.refreshCookieName}",required = false)String refreshToken) {
        refreshTokenService.revokedRefreshToken(refreshToken);
        SecurityContextHolder.clearContext();

        ResponseCookie clearCookie = cookieUtil.clearRefreshCookie();
        Map<String, String> response = new HashMap<>();
        response.put("message", "Đăng xuất thành công!");
        return ResponseEntity.ok()
                .header(HttpHeaders.SET_COOKIE, clearCookie.toString())
                .body(response);
    }

    

}

// File: news-services/src/main/java/com/news/news_services/config/SecurityConfig.java
package com.news.news_services.config;

import com.news.news_services.security.AuthEntryPointJwt;
import com.news.news_services.security.JwtAuthenticationFilter;
import com.news.news_services.security.UserDetailServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.beans.factory.annotation.Autowired;
import com.news.news_services.security.OAuth2LoginSuccessHandler;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
public class SecurityConfig {

    @Autowired
    UserDetailServiceImpl userDetailService;
    @Autowired
    private JwtAuthenticationFilter jwtAuthenticationFilter;

    @Autowired
    private OAuth2LoginSuccessHandler oAuth2LoginSuccessHandler;

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Autowired
    private AuthEntryPointJwt authEntryPointJwt;


    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailService);
        authProvider.setPasswordEncoder(passwordEncoder());

        return authProvider;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }



    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Arrays.asList(
            "http://localhost:3000", 
            "https://hiepnguyen.click", 
            "https://www.hiepnguyen.click",
            "http://150.95.109.169:3000",
            "http://150.95.109.169",
            "http://hiepnguyen.click",
                "http://localhost:3001"
        ));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE","PATCH", "OPTIONS"));
        configuration.setAllowedHeaders(Arrays.asList("*"));
        configuration.setAllowCredentials(true); 

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        
        http.cors(cors -> cors.configurationSource(corsConfigurationSource()))
                .csrf(csrf -> csrf.disable())
//                .exceptionHandling(exception ->
//                        exception.authenticationEntryPoint(authEntryPointJwt)
//                )
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(auth ->
                        auth
                                .requestMatchers("/").permitAll()
                                .requestMatchers("/login").permitAll()
                                .requestMatchers("/oauth2/**").permitAll()
                                .requestMatchers("/api/oauth2/**").permitAll()
                                .requestMatchers("/api/auth/signin").permitAll()
                                .requestMatchers("/api/auth/signup").permitAll()
                                .requestMatchers("/api/auth/refresh").permitAll() // Phải đặt TRƯỚC /api/auth/**
                                .requestMatchers("/api/tags/**").permitAll()
                                .requestMatchers("/api/news/test").permitAll()
                                .requestMatchers(HttpMethod.GET, "/api/news/**").permitAll()
                                .requestMatchers(HttpMethod.GET, "/api/live-content/**").permitAll()
                                .requestMatchers("/api/category/**").permitAll()
                                .requestMatchers(HttpMethod.POST, "/api/news/create").hasRole("USER")
                                .requestMatchers(HttpMethod.POST, "/api/media/upload").authenticated() // Upload media cho TinyMCE
                                .requestMatchers(HttpMethod.POST, "/api/media/upload-news").authenticated()
                                .requestMatchers("/api/news/my-news/**").authenticated()
                                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                                .requestMatchers("/ws/**").permitAll()
//                                .requestMatchers("/api/auth/**").authenticated() // Các endpoint /api/auth khác cần auth
                                .anyRequest().authenticated()
                        )
                .oauth2Login(oauth2 -> {
                    oauth2.loginPage("/login")
                            .successHandler(oAuth2LoginSuccessHandler)
                            .failureUrl("https://hiepnguyen.click/login?error=fail");
                });

        http.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);
        return http.build();
    }

}

// File: news-services/src/main/java/com/news/news_services/security/JwtAuthenticationFilter.java
package com.news.news_services.security;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter
{
    @Autowired
    private JwtUtil jwtUtil;

    @Autowired
    private UserDetailServiceImpl userDetailsService;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        try {
            String jwt = parseJwt(request);

            if(jwt != null && jwtUtil.validationJwtToken(jwt)) {
                String username = jwtUtil.getUserNameFromToken(jwt);
                UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                UsernamePasswordAuthenticationToken authentication =
                        new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        }
        catch (Exception e) {
            System.err.println("Cannot set user authentication: " + e.getMessage());
        }
        filterChain.doFilter(request, response);
    }

    private String parseJwt(HttpServletRequest request) {
        String header = request.getHeader("Authorization");
        if (StringUtils.hasText(header) && header.startsWith("Bearer ")) {
            return header.substring(7);
        }

        return null;
    }


}

// File: news-services/src/main/java/com/news/news_services/security/UserDetailServiceImpl.java
package com.news.news_services.security;

import com.news.news_services.entity.User;
import com.news.news_services.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class UserDetailServiceImpl implements UserDetailsService{
    @Autowired
    UserRepository userRepository;

    @Override
    @Transactional
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsernameAndStatus(username,User.UserStatus.ACTIVE)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with username or Inactive: " + username));
        return UserPrincipal.create(user);
    }
}

// File: news-services/src/main/java/com/news/news_services/security/UserPrincipal.java
package com.news.news_services.security;

import com.news.news_services.entity.User;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.List;
import java.util.Objects;

public class UserPrincipal implements UserDetails{

    private Long id;
    private String username;
    private String email;
    private String password;
    private Collection<? extends GrantedAuthority> authorities;

    public UserPrincipal(Long id, String username, String email, String password, User.UserStatus status, Collection<? extends GrantedAuthority> authorities) {
        this.id = id;
        this.username = username;
        this.email = email;
        this.password = password;
        this.status = status;
        this.authorities = authorities;
    }

    private User.UserStatus status;
    public static UserPrincipal create(User user){
        List<GrantedAuthority> authorities = List.of(
                new SimpleGrantedAuthority("ROLE_"+user.getRole().name())
        );

        return new UserPrincipal(
                user.getId(),
                user.getUsername(),
                user.getEmail(),
                user.getPassword(),
                user.getStatus(),
                authorities);

    }

    public Long getId() {return id;}
    public String getEmail() {return email;}

    @Override
    public String getUsername() {return username;}
    @Override
    public String getPassword() {return password;}
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {return authorities;}

    @Override
    public boolean isAccountNonExpired() {return true;}

    @Override
    public boolean isAccountNonLocked() {return true;}

    @Override
    public boolean isCredentialsNonExpired() {return true;}

    @Override
    public boolean isEnabled() {
        return status == User.UserStatus.ACTIVE; //

    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        UserPrincipal that = (UserPrincipal) o;
        return Objects.equals(id, that.id);
    }
    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

}

// File: news-services/src/main/java/com/news/news_services/security/OAuth2LoginSuccessHandler.java
package com.news.news_services.security;

import com.news.news_services.entity.User;
import com.news.news_services.entity.User;
import com.news.news_services.repository.UserRepository;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.Authentication;
import org.springframework.security.oauth2.core.user.OAuth2User;
import org.springframework.security.web.authentication.AuthenticationSuccessHandler;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.Optional;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.Optional;

@Component
public class OAuth2LoginSuccessHandler implements AuthenticationSuccessHandler {

    @Autowired
    private JwtUtil jwtUtil;

    @Autowired
    private UserRepository userRepository;



    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
        if (authentication == null || authentication.getPrincipal() == null) {
            response.sendRedirect("https://hiepnguyen.click/login?error=oauth2_failed");
            return;
        }

        OAuth2User oAuth2User = (OAuth2User) authentication.getPrincipal();
        String name = (String) oAuth2User.getAttributes().get("name");
        String email = (String) oAuth2User.getAttributes().get("email");
        String picture = (String) oAuth2User.getAttributes().get("picture");

        Optional<User> existing = userRepository.findByEmail(email);
        User user;
        if (existing.isPresent()) {
            user = existing.get();
        } else {
            user = new User();
            user.setEmail(email);
            user.setFullName(name);
            user.setUsername(email);
            user.setPassword("");
            user.setStatus(User.UserStatus.ACTIVE);
            user.setRole(User.UserRole.USER);
            user.setAvatarUrl(picture);
            user = userRepository.save(user);
        }

        // Tạo JWT token
        String jwtToken = jwtUtil.generateTokenFromUsername(user.getUsername());
        
        // Redirect về frontend với token
        String frontendUrl = System.getenv("FRONTEND_URL");
        if (frontendUrl == null || frontendUrl.isEmpty()) {
            frontendUrl = "https://hiepnguyen.click";
        }
        String redirectUrl = frontendUrl + "/oauth2/callback?token=" + URLEncoder.encode(jwtToken, StandardCharsets.UTF_8);
        response.sendRedirect(redirectUrl);
    }}


// File: news-services/src/main/java/com/news/news_services/dto/LoginRequest.java
package com.news.news_services.dto;

import jakarta.validation.constraints.NotBlank;

public class LoginRequest {
    @NotBlank
    private String username;
    @NotBlank
    private String password;

    public LoginRequest() {
    }

    public LoginRequest(String username, String password) {}

    // Getters and Setters
    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }



    public void setPassword(String password) {
        this.password = password;
    }

}

// File: news-services/src/main/java/com/news/news_services/dto/SignupRequest.java
package com.news.news_services.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class SignupRequest {

    @NotBlank(message = "Username không được để trống")
    @Size(min = 3, max = 50, message = "Username phải từ 3-50 ký tự")
    private String username;

    @NotBlank(message = "Email không được để trống")
    @Email(message = "Email không hợp lệ")
    @Size(max = 100, message = "Email không được vượt quá 100 ký tự")
    private String email;

    @NotBlank(message = "Password không được để trống")
    @Size(min = 6, max = 40, message = "Password phải từ 6-40 ký tự")
    private String password;

    @Size(max = 100, message = "Họ tên không được vượt quá 100 ký tự")
    private String fullName;

    @Size(max = 20, message = "Số điện thoại không được vượt quá 20 ký tự")
    private String phone;

    public SignupRequest() {
    }

    public SignupRequest(String username, String email, String password, String fullName, String phone) {
        this.username = username;
        this.email = email;
        this.password = password;
        this.fullName = fullName;
        this.phone = phone;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getFullName() {
        return fullName;
    }

    public void setFullName(String fullName) {
        this.fullName = fullName;
    }

    public String getPhone() {
        return phone;
    }

    public void setPhone(String phone) {
        this.phone = phone;
    }
}

// File: news-services/src/main/java/com/news/news_services/dto/JwtResponse.java
package com.news.news_services.dto;

import com.news.news_services.entity.User;

public class JwtResponse {
    private String token;
    private String type = "Bearer";
    private Long id;
    private String username;
    private String email;
    private String fullName;
    private String role;
    private String status;

    public JwtResponse() {}

    public JwtResponse(String accessToken, Long id, String username, String email, String fullName, String role,String status) {
        this.token = accessToken;
        this.id = id;
        this.username = username;
        this.email = email;
        this.fullName = fullName;
        this.role = role;
        this.status = status;
    }

    public static JwtResponse build(String token, User user) {
        return new JwtResponse(
                token,
                user.getId(),
                user.getUsername(),
                user.getEmail(),
                user.getFullName(),
                user.getRole().name(),
                user.getStatus().name()
        );
    }

    public String getToken() {
        return token;
    }

    public void setToken(String token) {
        this.token = token;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getFullName() {
        return fullName;
    }

    public void setFullName(String fullName) {
        this.fullName = fullName;
    }

    public String getRole() {
        return role;
    }

    public void setRole(String role) {
        this.role = role;
    }
}

// File: news-services/src/main/java/com/news/news_services/dto/ExchangeTokenResponse.java
package com.news.news_services.dto;

import com.news.news_services.entity.User;

public class ExchangeTokenResponse {

    private String newRawRefreshToken; // Token mới để set vào cookie
    private User user; // User để tạo Access Token mới

    public ExchangeTokenResponse(String newRawRefreshToken, User user) {
        this.newRawRefreshToken = newRawRefreshToken;
        this.user = user;
    }

    // Getters
    public String getNewRawRefreshToken() {
        return newRawRefreshToken;
    }

    public User getUser() {
        return user;
    }
}

// File: news-frontend/src/services/api.js
import axios from "axios";
const API_URL = "/api";

const api = axios.create({
    baseURL: API_URL,
    withCredentials: true, // Rất quan trọng: để gửi cookie HttpOnly
});

// 1. CHÚNG TA KHÔNG DÙNG LOCALSTORAGE NỮA.
// Lưu Access Token (AT) trong bộ nhớ.
let inMemoryAccessToken = null;

// Hàm để AuthContext có thể set token này khi login/refresh
export const setAccessToken = (token) => {
    inMemoryAccessToken = token;
};

// Hàm để lấy token (cho WebSocket)
export const getAccessToken = () => {
    return inMemoryAccessToken;
};

// Interceptor GỬI request
api.interceptors.request.use(
    (config) => {
        // Lấy token từ bộ nhớ, không phải localStorage
        if (inMemoryAccessToken) {
            config.headers.Authorization = `Bearer ${inMemoryAccessToken}`;
        }
        return config;
    },
    (error) => Promise.reject(error)
);

// 2. INTERCEPTOR NHẬN RESPONSE (LOGIC QUAN TRỌNG NHẤT)
let isRefreshing = false;
let failedQueue = []; // Hàng đợi các request bị lỗi 401

const processQueue = (error, token = null) => {
    failedQueue.forEach(prom => {
        if (error) {
            prom.reject(error);
        } else {
            prom.resolve(token);
        }
    });
    failedQueue = [];
};

api.interceptors.response.use(
    (response) => response, // Nếu thành công, trả về
    async (error) => {
        const originalRequest = error.config;
        
        // Chỉ xử lý khi lỗi là 401 VÀ chưa từng thử lại request này
        if (error.response?.status === 401 && !originalRequest._retry) {
            
            if (isRefreshing) {
                // Nếu đang có 1 request refresh rồi, thì đưa request này vào hàng đợi
                return new Promise((resolve, reject) => {
                    failedQueue.push({ resolve, reject });
                }).then(token => {
                    originalRequest.headers.Authorization = 'Bearer ' + token;
                    return api(originalRequest); // Thử lại với token mới
                });
            }

            originalRequest._retry = true; // Đánh dấu là đã thử lại
            isRefreshing = true;

            try {
                // 3. Gọi API /refresh
                const rs = await api.post('/auth/refresh'); // Không cần payload, cookie đã được gửi
                
                const { accessToken } = rs.data;
                setAccessToken(accessToken); // Lưu AT mới vào bộ nhớ

                // Cập nhật AT cho request hiện tại và các request trong hàng đợi
                api.defaults.headers.common.Authorization = 'Bearer ' + accessToken;
                originalRequest.headers.Authorization = 'Bearer ' + accessToken;
                processQueue(null, accessToken); // Giải quyết hàng đợi

                isRefreshing = false;
                return api(originalRequest); // Thử lại request gốc

            } catch (_error) {
                // 4. Nếu REFRESH thất bại (RT hết hạn/bị thu hồi)
                isRefreshing = false;
                processQueue(_error, null); // Báo lỗi cho các request trong hàng đợi
                
                // Đăng xuất người dùng
                setAccessToken(null); // Xóa token
                
                // Gửi thông báo toàn cục để AuthContext biết và logout
                // (Cách này tốt hơn là redirect ở đây)
                window.dispatchEvent(new Event("auth-failed"));
                
                return Promise.reject(_error);
            }
        }

        return Promise.reject(error);
    }
);

export const newsAPI = {
    // Auth APIs
    login: async (credentials) => api.post("/auth/signin", credentials),
    signup: async (userData) => api.post("/auth/signup", userData),
    getCurrentUser: async () => api.get("/auth/me"), 
    logout: async () => api.post("/auth/logout"),

    // API Refresh mới
    refreshToken: async () => api.post("/auth/refresh"),
    // Profile APIs (current user)
    updateMyProfile: async (payload) => api.put('/auth/me', payload),

    // OAuth2 Google Login API
    googleLogin: async () => api.get('/oauth2/callback'),
};

export default api;

// File: news-frontend/src/components/AuthContext.js
import React, { createContext, useState, useContext, useEffect } from 'react';
import { newsAPI, setAccessToken } from '../services/api';

const AuthContext = createContext();
let isRefreshing = false;

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [isAuthenticated, setIsAuthenticated] = useState(false);


  useEffect(() => {
    checkAuthStatus();
    const handleAuthFailure = () => {
      setUser(null);
      setIsAuthenticated(false);
      setLoading(false);
      window.location.href = '/login';
    };
    window.addEventListener("auth-failed", handleAuthFailure);
  
    return () => {
        window.removeEventListener("auth-failed", handleAuthFailure);
  };
  }, []);


  const checkAuthStatus = async () => {
    if (isRefreshing) {
      return;
    }

    try {
      isRefreshing = true;
      setLoading(true); 
      
      const response = await newsAPI.refreshToken();
      const { accessToken } = response.data;
      
      setAccessToken(accessToken);

      const userRefreshed = await refreshUser();
      
      if (!userRefreshed) {
        setUser(null);
        setIsAuthenticated(false);
      }

    } catch (error) {

      setUser(null);
      setIsAuthenticated(false);
    } finally {
      isRefreshing = false;
      setLoading(false);
    }
  };

  const refreshUser = async () => {
    try {
      const response = await newsAPI.getCurrentUser();
      const userData = response.data;

      if (userData.status !== 'ACTIVE') {
          await logout(); 
          return false;
      }
      
      setUser(userData);
      setIsAuthenticated(true);
      return true;
  } catch (e) {
      setUser(null);
      setIsAuthenticated(false);
      return false;
  }
  };

  const oauth2Login = async (token,userData) => {
    try {
      setAccessToken(token);
      setUser(userData);
      setIsAuthenticated(true);
      return { success: true, user: userData };
  } catch (error) {
      return { success: false, error: 'Đăng nhập thất bại' };
  }
  };

  const login = async (credentials) => {
    try {
      const response = await newsAPI.login(credentials);
      const { token, ...userData } = response.data;

      setAccessToken(token);
      
      setUser(userData);
      setIsAuthenticated(true);
      
      return { success: true, user: userData };
    } catch (error) {
      return { 
        success: false, 
        error: error.response?.data?.error || 'Đăng nhập thất bại' 
      };
    }
  };

  const signup = async (userData) => {
    try {
      const response = await newsAPI.signup(userData);
      return { success: true, data: response.data };
    } catch (error) {
      return { 
        success: false, 
        error: error.response?.data?.error || 'Đăng ký thất bại' 
      };
    }
  };

  const logout = async () => {
    try {
      await newsAPI.logout(); 
  } catch (error) {
  } finally {
      setAccessToken(null);
      setUser(null);
      setIsAuthenticated(false);
      
      localStorage.removeItem('token'); 
  }
  };

  const value = {
    user,
    isAuthenticated,
    loading,
    login,
    signup,
    logout,
    oauth2Login,
    refreshUser
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};

// File: news-frontend/src/components/ProtectedRoute.js
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from '../components/AuthContext';

const ProtectedRoute = ({ children }) => {
  const { isAuthenticated, loading } = useAuth();
  const location = useLocation();

  if (loading) {
    return (
      <div className="d-flex justify-content-center align-items-center" style={{minHeight: '200px'}}>
        <div className="spinner-border text-primary" role="status">
          <span className="visually-hidden">Đang tải...</span>
        </div>
      </div>
    );
  }

  if (!isAuthenticated) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  return children;
};

export default ProtectedRoute;

// File: news-frontend/src/components/AdminRoute.js
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from './AuthContext';

const AdminRoute = ({ children }) => {
  const { isAuthenticated, user, loading } = useAuth();
  const location = useLocation();

  if (loading) {
    return (
      <div className="d-flex justify-content-center align-items-center" style={{minHeight: '200px'}}>
        <div className="spinner-border text-primary" role="status">
          <span className="visually-hidden">Đang tải...</span>
        </div>
      </div>
    );
  }

  if (!isAuthenticated) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  if (user?.role !== 'ADMIN') {
    return (
      <div className="container py-5">
        <div className="alert alert-danger">
          <h4>Truy cập bị từ chối</h4>
          <p>Bạn không có quyền truy cập trang quản trị này.</p>
        </div>
      </div>
    );
  }

  return children;
};

export default AdminRoute;

// File: news-frontend/src/components/GuestRoute.js
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from './AuthContext';

const GuestRoute = ({ children }) => {
  const { isAuthenticated, loading } = useAuth();
  const location = useLocation();

  if (loading) {
    return (
      <div className="d-flex justify-content-center align-items-center" style={{minHeight: '200px'}}>
        <div className="spinner-border text-primary" role="status">
          <span className="visually-hidden">Đang tải...</span>
        </div>
      </div>
    );
  }

  if (isAuthenticated) {
    // Nếu có trang trước đó, redirect về đó, nếu không thì về trang chủ
    const from = location.state?.from?.pathname || '/';
    return <Navigate to={from} replace />;
  }

  return children;
};

export default GuestRoute;

